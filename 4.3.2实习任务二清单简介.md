- 在原有的基础上添加了color菜单, 添加了Black、 Green、 Yellow 菜单项:

	```cpp
		blackAction=new QAction(QIcon("black.png"),tr("黑色"),this);
		blackAction->setStatusTip (tr("填充黑色"));
	
		greenAction=new QAction(QIcon("green.png"),tr("绿色"),this);
		greenAction->setStatusTip (tr("填充绿色"));
	
		yellowAction=new QAction(QIcon("yellow.png"),tr("黄色"),this);
		yellowAction->setStatusTip (tr("填充黄色"));
	
		colorMenu=this->menuBar ()->addMenu (tr("颜色"));
	```

	并连接了信号槽:

	```cpp
	connect (blackAction,SIGNAL(triggered()),this,SLOT(reDrawInBlack()));
	connect (greenAction,SIGNAL(triggered()),this,SLOT(reDrawInGreen()));
	connect (yellowAction,SIGNAL(triggered()),this,SLOT(reDrawInYellow()));
	```

	其中的槽函数定义:

	```cpp
	void MainWindow::reDrawInBlack()
	{
		centerWidget->setDrawColor (Qt::black);
		centerWidget->update ();
		return ;
	}
	
	void MainWindow::reDrawInGreen()
	{
		centerWidget->setDrawColor (Qt::green);
		centerWidget->update ();
		return ;
	}
	
	void MainWindow::reDrawInYellow()
	{
		centerWidget->setDrawColor (Qt::yellow);
		centerWidget->update ();
		return ;
	}
	```

	实现的方法是在CenterWidget类的定义中添加了一个private变量用于储存颜色:

	```cpp
	Qt::GlobalColor DRAW_COLOR;
	```

	添加修改函数:

	```cpp
	void CenterWidget::setDrawColor(Qt::GlobalColor color)
	{
		this->DRAW_COLOR=color;
		return ;
	}
	```

	并将paintEvent中画笔和画刷的颜色参数改为DRAW_COLOR:

	```cpp
	void CenterWidget::paintEvent(QPaintEvent *){
	
		QPainter p(this);
		QPen pen(DRAW_COLOR,2,Qt::SolidLine);
		QBrush bruch(DRAW_COLOR, Qt::SolidPattern);
		QPoint p1(50,50),p2(500,300);
		if(FILL_FLAG){
			p.setBrush (bruch);
		}else{
			p.setPen(pen);
		}
		switch(drawType){
			case 0:
				p.drawLine(p1,p2);
				break;
			case 1:
				p.drawEllipse(QRect(p1,p2));
				break;
			case 2:
				p.drawRect(QRect(p1,p2));
				break;
		}
		p.drawText(50,200,mouseClickInfo);
		p.drawText(50,300,mousePosInfo);
		p.drawText(50,300,this->KeyPressInfo);
	}
	```



____



- 添加了菜单项 Fill，点击后切换是否填充图形，默认为不填充:

	```cpp
	fillAction=new QAction(tr("填充"),this);
	
	fillMenu=this->menuBar ()->addMenu (tr("填充"));
	
	connect (fillAction, SIGNAL(triggered()),this,SLOT(fillColor()));
	
	void MainWindow::fillColor()
	{
		int answer=QMessageBox::question (this, tr("对话框"), tr("是否填充图像"),
							   QMessageBox::Yes, QMessageBox::No);
		if(answer==QMessageBox::Yes){
			centerWidget->setFillOption (true);
		}else{
			centerWidget->setFillOption (false);
		}
		centerWidget->update ();
		return ;
	}
	```

	其中的实现采用QMessageBox弹出一个question, 询问用户的选择, 并通过返回值判定结果

	具体的实现是在CenterWidget类定义中添加了一个标志变量表示是否填充图像:

	```cpp
	bool FILL_FLAG;
	```

	并定义函数用于修改:

	```cpp
	void CenterWidget::setFillOption(bool flag)
	{
		this->FILL_FLAG=flag;
		return ;
	}
	```

	而后修改paintEvent函数, 通过这个标志位来选择使用画笔还是画刷:

	```cpp
	void CenterWidget::paintEvent(QPaintEvent *){
	
		QPainter p(this);
		QPen pen(DRAW_COLOR,2,Qt::SolidLine);
		QBrush bruch(DRAW_COLOR, Qt::SolidPattern);
		QPoint p1(50,50),p2(500,300);
		if(FILL_FLAG){
			p.setBrush (bruch);
		}else{
			p.setPen(pen);
		}
		switch(drawType){
			case 0:
				p.drawLine(p1,p2);
				break;
			case 1:
				p.drawEllipse(QRect(p1,p2));
				break;
			case 2:
				p.drawRect(QRect(p1,p2));
				break;
		}
		p.drawText(50,200,mouseClickInfo);
		p.drawText(50,300,mousePosInfo);
		p.drawText(50,300,this->KeyPressInfo);
	}
	```

	